#include <stdio.h>
#include "hardware.h"

void execute_dataproc(unsigned ir, unsigned type, registers *regs)
{
	unsigned int operation = (ir & 0xF00) >> 8, source = (ir & 0xF0) >> 4, destination = (ir & 0x000F);
	printf("Operation: %X\nSource: %X\nDestination: %X\n", operation, source, destination);
	switch(operation)
	{
		// ADC
		case 0x5:
			regs->CARRY = iscarry(source, destination, regs->CARRY);
			break;
		default:
			perror("Operation not found");	
	}
}

/**********************************************************
*   iscarry()- determine if carry is generated by addition: op1+op2+C
*     C can only have value of 1 or 0.
************************************************************/
int iscarry(unsigned long op1,unsigned long op2, unsigned C){
if ((op2 == MAX32)&&(C == 1)) 
	return(1); // special case where op2 is at MAX32
return((op1 > (MAX32 - op2 - C))?1:0);
}

void execute_load(unsigned ir, unsigned type, registers *regs, uint8_t *memptr)
{
	unsigned int load_bit = (ir & 0x800) >> 11, word_bit = (ir & 0x400) >> 10, address = (ir & 0x0F0) >> 4, destination = (ir & 0x000F);
	int i = 0;
	
	switch(load_bit)
	{
		// Store
		case 0:
			// Word
			if(word_bit == 0)	
			{
				regs->MAR = regs->R[address];
				regs->MBR = regs->R[destination];
				for(i = 1; i >= 0; i--)
				{
					memptr[regs->MAR + i] = regs->MBR;
					regs->MBR = regs->MBR >> 8;
				}
			}
			// Byte
			else if(word_bit == 1)
			{
				regs->MAR = regs->R[address];
				regs->MBR = regs->R[destination];
				memptr[regs->MAR] = regs->MBR;
			}
			break;
		// Load
		case 1:
			// Load word
			if(word_bit == 0)
			{
				regs->MAR = regs->R[address];
				for(i = 1; i >= 0; i--)
				{
					regs->MBR += memptr[regs->MAR + i];
					regs->MBR = regs->MBR >> 8;
				}
				regs->R[destination] = regs->MBR;
			}
			// Load byte
			else if(word_bit == 1)
			{
				regs->MAR = regs->R[address] & 0x000000FF;
				regs->MBR = memptr[regs->MAR];
				regs->R[destination] = regs->MBR;
			}
			break;
	}	
}

void execute_immediate(unsigned ir, unsigned type, registers *regs)
{
	unsigned int opcode = (ir & 0x3000) >> 12, value = (ir & 0x0FF0) >> 4, destination = (ir & 0x000F);
	switch(opcode)
	{
		/* MOV */
		case 0x0:
			regs->R[destination] = value;
			break;
		/* CMP */
		case 0x1:
			regs->R[destination] -= value;
			break;
		/* ADD */
		case 0x2:
			regs->R[destination] += value;	
			break;
		/* SUB */
		case 0x3:
			regs->R[destination] -= value;	
			break;
		
	}
}

void execute_cbranch(unsigned ir, unsigned type, registers *regs)
{
	unsigned int condition = (ir & 0xF00) >> 8, address = ir & 0xFF;
	switch(condition)
	{
		case 0x0:
			if(regs->ZERO == true)
				regs->PC = address;
			break;
		case 0x1:
			if(regs->ZERO == false)
				regs->PC = address;	
			break;
		case 0x2:
			if(regs->CARRY = true)
				regs->PC = address;
			break;
		case 0x3:
			if(regs->CARRY = false)
				regs->PC = address;
			break;
		case 0x4:
			if(regs->SIGN == true)
				regs->PC = address;
			break;
		//case 0x5:
		//case 0x8:
		//case 0x9:
		//case 0xE:
	}
}

void execute_ubranch(unsigned ir, unsigned type, registers *regs)
{
	unsigned int link = (ir & 0x1000) >> 12, offset = ir & 0xFFF;
	if(link == 0)
	{
		regs->PC = offset;
	}
	else
	{
		regs->LR = regs->PC;
		regs->PC = offset;
	}
}